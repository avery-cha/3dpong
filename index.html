<html>

<head>
  <meta charset=utf-8>
  <title>My first three.js app</title>
  <style>
    body {
      margin: 0;
    }

    canvas {
      width: 100%;
      height: 100%
    }
  </style>
</head>

<body>
  <script src="js/three.js"></script>
  <script>

    var xCollidableList = [];
    var yCollidableList = [];
    var zCollidableList = [];
    var netCollidableList = [];
      
    
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);


    // ** Create Objects **
    var sphereGeometry = new THREE.SphereGeometry(1, 8, 6);
    var sphereMaterial = new THREE.MeshBasicMaterial( {color: 0xcc00ff} );
    var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
    scene.add( sphere );

    // ** Create Walls **
    var planeGeometry = new THREE.PlaneGeometry(20.25, 20.25, 32, 32);
    // var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    var planeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ee00, wireframe: true, transparent: true }); 

    var rightPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    rightPlane.translateX( 10 );
    rightPlane.rotation.y = 3.14159 / 2;
    scene.add(rightPlane);
    yCollidableList.push(rightPlane);
    var rightPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    rightPlane.translateX( 10 );
    rightPlane.rotation.y = 3.14159 / 2;
    scene.add(rightPlane);

    var leftPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    leftPlane.translateX( -10 );
    leftPlane.rotation.y = 3.14159 / 2;
    scene.add(leftPlane);
    yCollidableList.push(leftPlane);
    var leftPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    leftPlane.translateX( 10 );
    leftPlane.rotation.y = 3.14159 / 2;
    scene.add(leftPlane);

    var topPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    topPlane.translateY( 10 );
    topPlane.rotation.x = 3.14159 / 2;
    scene.add(topPlane);
    xCollidableList.push(topPlane);
    var topPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    topPlane.translateY( 10 );
    topPlane.rotation.x = 3.14159 / 2;
    scene.add(topPlane);

    var bottomPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    bottomPlane.translateY( -10 );
    bottomPlane.rotation.x = 3.14159 / 2;
    scene.add(bottomPlane);
    xCollidableList.push(bottomPlane);
    var bottomPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    bottomPlane.translateY( 10 );
    bottomPlane.rotation.x = 3.14159 / 2;
    scene.add(bottomPlane);

    // var backPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    // backPlane.translateZ( -10 );
    // scene.add(backPlane);
    // zCollidableList.push(backPlane);
    // var backPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    // backPlane.translateZ( -10 );
    // scene.add(backPlane);

    // var frontPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    // frontPlane.translateZ( 10 );
    // scene.add(frontPlane);
    // zCollidableList.push(frontPlane);
    // var frontPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    // frontPlane.translateZ( 10 );
    // scene.add(frontPlane);

    // ** Create paddles **
    var paddleGeometry = new THREE.PlaneGeometry(5, 3, 32, 32);
    var playerPaddleMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ee, wireframe: true, transparent: true }); 

    var playerPaddle1 = new THREE.Mesh(paddleGeometry, playerPaddleMaterial)
    playerPaddle1.translateZ( 10 );
    scene.add(playerPaddle1);
    zCollidableList.push(playerPaddle1);
    var playerPaddle2 = new THREE.Mesh(paddleGeometry, playerPaddleMaterial);
    playerPaddle2.translateZ( 10 );
    scene.add(playerPaddle2);

    var computerPaddleMaterial = new THREE.MeshBasicMaterial({ color: 0xee0000, wireframe: true, transparent: true }); 
    var computerPaddle1 = new THREE.Mesh(paddleGeometry, computerPaddleMaterial)
    computerPaddle1.translateZ(-10);
    scene.add(computerPaddle1);
    zCollidableList.push(computerPaddle1);
    var computerPaddle2 = new THREE.Mesh(paddleGeometry, computerPaddleMaterial);
    computerPaddle2.translateZ(-10);
    scene.add(computerPaddle2);

    // ** Create 'nets' behind player paddles **
    var netGeometry = new THREE.PlaneGeometry(60, 60, 60, 120);
    var netMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true }); 
    var playerNet = new THREE.Mesh(netGeometry, netMaterial)
    playerNet.translateZ(24);
    scene.add(playerNet);
    netCollidableList.push(playerNet);
    var playerNet = new THREE.Mesh(netGeometry, netMaterial);
    playerNet.translateZ(24);
    scene.add(playerNet);

    var netGeometry = new THREE.PlaneGeometry(60, 60, 60, 120);
    var netMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true }); 
    var computerNet = new THREE.Mesh(netGeometry, netMaterial)
    computerNet.translateZ(-24);
    scene.add(computerNet);
    netCollidableList.push(computerNet);
    var computerNet = new THREE.Mesh(netGeometry, netMaterial);
    computerNet.translateZ(-24);
    scene.add(computerNet);


    // ** Below code is to enable mouse control of the paddle **
    // Code created with the help of Stack Overflow question
    // https://stackoverflow.com/questions/13055214/mouse-canvas-x-y-to-three-js-world-x-y-z
    // Question by Rob Evans:
    // https://stackoverflow.com/users/599020/rob-evans
    // Answer by WestLangley:
    // https://stackoverflow.com/users/1461008/westlangley

    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    var vector = new THREE.Vector3();

    document.addEventListener('mousemove', onDocumentMouseMove, false);

    function onDocumentMouseMove(event) {
      event.preventDefault();

      vector.set(
        (event.clientX / window.innerWidth ) * 2 - 1,
        (event.clientY / window.innerHeight ) * 2 - 1,
        0.5
      )
      vector.unproject(camera);
      var dir = vector.sub(camera.position).normalize();
      var distance = (10 - camera.position.z) / dir.z;
      var pos = camera.position.clone().add(dir.multiplyScalar(distance));

      playerPaddle1.position.set(
        pos.x, -pos.y, pos.z);
      playerPaddle2.position.set(
        pos.x, -pos.y, pos.z);
    }

    // ** Below code is to enable WASD keyboard control of the paddle **
    // let xSpeed = 2.25;
    // let ySpeed = 2.25;

    // document.addEventListener("keydown", onDocumentKeyDown, false);
    // function onDocumentKeyDown(event) {
    //   var keyCode = event.which;
    //   if (keyCode == 87) {
    //     playerPaddle1.position.y += ySpeed;
    //   } else if (keyCode == 83) {
    //     playerPaddle1.position.y -= ySpeed;
    //   } else if (keyCode == 65) {
    //     playerPaddle1.position.x -= xSpeed;
    //   } else if (keyCode == 68) {
    //     playerPaddle1.position.x += xSpeed;
    //   } else if (keyCode == 32) {
    //     playerPaddle1.position.set(0, 0, 0);
    //   }
    //   if (keyCode == 87) {
    //     playerPaddle2.position.y += ySpeed;
    //   } else if (keyCode == 83) {
    //     playerPaddle2.position.y -= ySpeed;
    //   } else if (keyCode == 65) {
    //     playerPaddle2.position.x -= xSpeed;
    //   } else if (keyCode == 68) {
    //     playerPaddle2.position.x += xSpeed;
    //   } else if (keyCode == 32) {
    //     playerPaddle2.position.set(0, 0, 0);
    //   }
    // };


    camera.position.z = 24;

    var computerPaddleXSpeed = 0.2;
    var computerPaddleYSpeed = 0.2;

    function moveComputerPaddle() {
      if (sphere.position.x > computerPaddle1.position.x) {
        computerPaddle1.translateX(computerPaddleXSpeed);
        computerPaddle2.translateX(computerPaddleXSpeed);
      }
      if (sphere.position.y > computerPaddle1.position.y) {
        computerPaddle1.translateY(computerPaddleYSpeed);
        computerPaddle2.translateY(computerPaddleYSpeed);
      }
      if (sphere.position.x < computerPaddle1.position.x) {
        computerPaddle1.translateX(-computerPaddleXSpeed);
        computerPaddle2.translateX(-computerPaddleXSpeed);
      }
      if (sphere.position.y < computerPaddle1.position.y) {
        computerPaddle1.translateY(-computerPaddleYSpeed);
        computerPaddle2.translateY(-computerPaddleYSpeed);
      }

    }

    var xBallVelocity = 1;    
    var yBallVelocity = 1; 
    var zBallVelocity = -1;  

    function animate() {

      requestAnimationFrame(animate);
      render();
      // update();

      moveComputerPaddle();

      var originPoint = sphere.position.clone();
      for (var vertexIndex = 0; vertexIndex < sphere.geometry.vertices.length; vertexIndex++) {
        var localVertex = sphere.geometry.vertices[vertexIndex].clone();
        var globalVertex = localVertex.applyMatrix4(sphere.matrix);
        var directionVector = globalVertex.sub(sphere.position);
        
        var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
        var xCollisionResults = ray.intersectObjects(xCollidableList);
        if (xCollisionResults.length > 0 && xCollisionResults[0].distance < directionVector.length()) {
          yBallVelocity = -yBallVelocity;
        }

        var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
        var yCollisionResults = ray.intersectObjects(yCollidableList);
        if (yCollisionResults.length > 0 && yCollisionResults[0].distance < directionVector.length()) {
          xBallVelocity = -xBallVelocity;
        }
        
        var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
        var zCollisionResults = ray.intersectObjects(zCollidableList);
        if (zCollisionResults.length > 0 && zCollisionResults[0].distance < directionVector.length()) {
          zBallVelocity = -zBallVelocity;
        }

        var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
        var netCollisionResults = ray.intersectObjects(netCollidableList);
        if (netCollisionResults.length > 0 && netCollisionResults[0].distance < directionVector.length()) {
          zBallVelocity = -zBallVelocity;
          // scene.remove( sphere );
          sphere.position.set(0, 0, 0)
          // sphere.translateX(0);
          // sphere.translateY(0);
          // sphere.translateZ(0);
          // scene.add( sphere );
        }
      }

      sphere.translateX(xBallVelocity);
      sphere.translateY(yBallVelocity);
      sphere.translateZ(zBallVelocity);
      }

    function render() {
        renderer.render(scene, camera);
      }

    // function update() {
    
    // }

    animate();

  </script>
</body>

</html>