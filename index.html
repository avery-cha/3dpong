<html>

<head>
  <meta charset=utf-8>
  <title>My first three.js app</title>
  <style>
    body {
      margin: 0;
    }

    canvas {
      width: 100%;
      height: 100%
    }
  </style>
</head>

<body>
  <script src="js/three.js"></script>
  <script>

    var xCollidableList = [];
    var yCollidableList = [];
    var zCollidableList = [];
      
    
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);


    var sphereGeometry = new THREE.SphereGeometry(1, 8, 6);
    var sphereMaterial = new THREE.MeshBasicMaterial( {color: 0x0000ff} );
    var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
    scene.add( sphere );



    // var lineMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff })

    // var lineGeometry = new THREE.Geometry();
    // lineGeometry.vertices.push(new THREE.Vector3(-10, 0, 0));
    // lineGeometry.vertices.push(new THREE.Vector3(0, 10, 0));
    // lineGeometry.vertices.push(new THREE.Vector3(10, 0, 0));

    // var line = new THREE.Line(lineGeometry, lineMaterial);
    // scene.add(line)


    var planeGeometry = new THREE.PlaneGeometry(20.25, 20.25, 32, 32);
    // var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    var planeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ee00, wireframe: true, transparent: true }); 

    var rightPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    rightPlane.translateX( 10 );
    rightPlane.rotation.y = 3.14159 / 2;
    scene.add(rightPlane);
    yCollidableList.push(rightPlane);
    var rightPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    rightPlane.translateX( 10 );
    rightPlane.rotation.y = 3.14159 / 2;
    scene.add(rightPlane);

    var leftPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    leftPlane.translateX( -10 );
    leftPlane.rotation.y = 3.14159 / 2;
    scene.add(leftPlane);
    yCollidableList.push(leftPlane);
    var leftPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    leftPlane.translateX( 10 );
    leftPlane.rotation.y = 3.14159 / 2;
    scene.add(leftPlane);

    var topPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    topPlane.translateY( 10 );
    topPlane.rotation.x = 3.14159 / 2;
    scene.add(topPlane);
    xCollidableList.push(topPlane);
    var topPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    topPlane.translateY( 10 );
    topPlane.rotation.x = 3.14159 / 2;
    scene.add(topPlane);

    var bottomPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    bottomPlane.translateY( -10 );
    bottomPlane.rotation.x = 3.14159 / 2;
    scene.add(bottomPlane);
    xCollidableList.push(bottomPlane);
    var bottomPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    bottomPlane.translateY( 10 );
    bottomPlane.rotation.x = 3.14159 / 2;
    scene.add(bottomPlane);

    var backPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    backPlane.translateZ( -10 );
    scene.add(backPlane);
    zCollidableList.push(backPlane);
    var backPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    backPlane.translateZ( -10 );
    scene.add(backPlane);

    var frontPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    frontPlane.translateZ( 10 );
    scene.add(frontPlane);
    zCollidableList.push(frontPlane);
    var frontPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    frontPlane.translateZ( 10 );
    scene.add(frontPlane);


    var paddleGeometry = new THREE.PlaneGeometry(5, 3, 32, 32);
    var paddleMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ee, wireframe: true, transparent: true }); 

    var playerPaddle = new THREE.Mesh(paddleGeometry, paddleMaterial)
    playerPaddle.translateZ( 10 );
    scene.add(playerPaddle);
    zCollidableList.push(playerPaddle);
    var playerPaddle = new THREE.Mesh(planeGeometry, planeMaterial);
    playerPaddle.translateZ(10);
    scene.add(playerPaddle);


    
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();

      function onMouseMove(event) {

        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

      }

    projector = new THREE.Projector();

    // when the mouse moves, call the given function
    document.addEventListener('mousemove', onDocumentMouseMove, false);


    camera.position.z = 25;


    var xBallVelocity = 0.2      
    var yBallVelocity = 0.2  
    var zBallVelocity = 0.3  

    function onDocumentMouseMove( event ) {
      // event.preventDefault();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
      console.log(event);
      playerPaddle.position.set(
        event.clientX,
        event.clientY,
        10 );
    }


    function animate() {

      requestAnimationFrame(animate);
      render();
      // update();
      // console.log(sphere.position);
      // console.log(xBallVelocity);

      var originPoint = sphere.position.clone();
      for (var vertexIndex = 0; vertexIndex < sphere.geometry.vertices.length; vertexIndex++) {
        var localVertex = sphere.geometry.vertices[vertexIndex].clone();
        var globalVertex = localVertex.applyMatrix4(sphere.matrix);
        var directionVector = globalVertex.sub(sphere.position);
        
        var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
        var xCollisionResults = ray.intersectObjects(xCollidableList);
        if (xCollisionResults.length > 0 && xCollisionResults[0].distance < directionVector.length()) {
          // sphere.position.x = 5;
          // xBallVelocity = -xBallVelocity;
          yBallVelocity = -yBallVelocity;
          // console.log(xBallVelocity);
        }

        var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
        var yCollisionResults = ray.intersectObjects(yCollidableList);
        if (yCollisionResults.length > 0 && yCollisionResults[0].distance < directionVector.length()) {
          // sphere.position.x = 5;
          xBallVelocity = -xBallVelocity;
          // yBallVelocity = -yBallVelocity;
          // console.log(xBallVelocity);
        }
        
        var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
        var zCollisionResults = ray.intersectObjects(zCollidableList);
        if (zCollisionResults.length > 0 && zCollisionResults[0].distance < directionVector.length()) {
          // sphere.position.x = 5;
          // xBallVelocity = -xBallVelocity;
          // yBallVelocity = -yBallVelocity;
          zBallVelocity = -zBallVelocity;
          
          // console.log(xBallVelocity);
        }
      }

      sphere.translateX(xBallVelocity);
      sphere.translateY(yBallVelocity);
      sphere.translateZ(zBallVelocity);
      }

    function render() {
        renderer.render(scene, camera);
      }

    // function update() {
    
    // }

    animate();

  </script>
</body>

</html>