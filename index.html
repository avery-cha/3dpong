<html>

<head>
  <meta charset=utf-8>
  <title>My first three.js app</title>
  <link rel="stylesheet" type="text/css" href="./css/style.scss" />
</head>

<body id="main">
  <div class="left-aside">
    3D Pong
    <br>
    <div class="instructions-title">
      How To Play:
    </div>
    <div class="instructions-text">
       The rules are the same as the classic game of pong. Use your mouse to control your paddle. Hit the ball onto your opponents
      side and prevent it from getting past your paddle. Score points by hitting the ball past your opponent. Win the game by scoring ten points. The game is over if ten points are scored against you.
    </div>
  </div>
  <div class="right-aside">
    <div class="score-title">
      Score
    </div>
    <div class="scores content">
      Player: <span id="player-score">0</span>
      <br>
      Comp: <span id="comp-score">0</span>
      <div class="difficulty-buttons">
        Select a difficulty:
        
        <button>Easy</button>
        <button>Medium</button>
        <button>Hard</button>
        <button>Impossible</button>
      </div>
    </div>
  </div>

  <script src="js/three.js"></script>
  <script>

    var xCollidableList = [];
    var yCollidableList = [];
    var zCollidableList = [];
    var netCollidableList = [];
      
    
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);


    // ** Create Objects **
    var sphereGeometry = new THREE.SphereGeometry(1, 8, 6);
    var sphereMaterial = new THREE.MeshBasicMaterial( {color: 0xffffff} );
    var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
    scene.add( sphere );

    // ** Create Walls **
    var planeGeometry = new THREE.PlaneGeometry(20.25, 20.25, 32, 32);
    // var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true }); 

    var horizPlaneGeometry = new THREE.PlaneGeometry(16, 20, 16, 20);
    var vertPlaneGeometry = new THREE.PlaneGeometry(20, 9, 20, 9);


    var rightPlane = new THREE.Mesh(vertPlaneGeometry, planeMaterial);
    rightPlane.translateX( 8 );
    rightPlane.translateZ( 0 );
    rightPlane.rotation.y = 3.14159 / 2;
    scene.add(rightPlane);
    yCollidableList.push(rightPlane);
    var rightPlane = new THREE.Mesh(vertPlaneGeometry, planeMaterial);
    rightPlane.translateX( 8 );
    rightPlane.translateZ( 0 );
    rightPlane.rotation.y = 3.14159 / 2;
    scene.add(rightPlane);

    var leftPlane = new THREE.Mesh(vertPlaneGeometry, planeMaterial);
    leftPlane.translateX( -8 );
    leftPlane.translateZ( 0 );
    leftPlane.rotation.y = 3.14159 / 2;
    scene.add(leftPlane);
    yCollidableList.push(leftPlane);
    var leftPlane = new THREE.Mesh(vertPlaneGeometry, planeMaterial);
    leftPlane.translateX( -8 );
    leftPlane.translateZ( 0 );
    leftPlane.rotation.y = 3.14159 / 2;
    scene.add(leftPlane);

    var topPlane = new THREE.Mesh(horizPlaneGeometry, planeMaterial);
    topPlane.translateY( 4.5 );
    topPlane.rotation.x = 3.14159 / 2;
    scene.add(topPlane);
    xCollidableList.push(topPlane);
    var topPlane = new THREE.Mesh(horizPlaneGeometry, planeMaterial);
    topPlane.translateY( 4.5 );
    topPlane.rotation.x = 3.14159 / 2;
    scene.add(topPlane);

    var bottomPlane = new THREE.Mesh(horizPlaneGeometry, planeMaterial);
    bottomPlane.translateY( -4.5 );
    bottomPlane.rotation.x = 3.14159 / 2;
    scene.add(bottomPlane);
    xCollidableList.push(bottomPlane);
    var bottomPlane = new THREE.Mesh(horizPlaneGeometry, planeMaterial);
    bottomPlane.translateY( 4.5 );
    bottomPlane.rotation.x = 3.14159 / 2;
    scene.add(bottomPlane);

    // var backPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    // backPlane.translateZ( -10 );
    // scene.add(backPlane);
    // zCollidableList.push(backPlane);
    // var backPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    // backPlane.translateZ( -10 );
    // scene.add(backPlane);

    // var frontPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    // frontPlane.translateZ( 10 );
    // scene.add(frontPlane);
    // zCollidableList.push(frontPlane);
    // var frontPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    // frontPlane.translateZ( 10 );
    // scene.add(frontPlane);

    // ** Create paddles **
    var paddleGeometry = new THREE.PlaneGeometry(3, 2, 32, 32);
    var playerPaddleMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ee, wireframe: true, transparent: true }); 

    var playerPaddle1 = new THREE.Mesh(paddleGeometry, playerPaddleMaterial)
    playerPaddle1.translateZ( 9.5 );
    scene.add(playerPaddle1);
    zCollidableList.push(playerPaddle1);
    var playerPaddle2 = new THREE.Mesh(paddleGeometry, playerPaddleMaterial);
    playerPaddle2.translateZ( 9.5 );
    scene.add(playerPaddle2);

    var computerPaddleMaterial = new THREE.MeshBasicMaterial({ color: 0xee0000, wireframe: true, transparent: true }); 
    var computerPaddle1 = new THREE.Mesh(paddleGeometry, computerPaddleMaterial)
    computerPaddle1.translateZ( -9.5 );
    scene.add(computerPaddle1);
    zCollidableList.push(computerPaddle1);
    var computerPaddle2 = new THREE.Mesh(paddleGeometry, computerPaddleMaterial);
    computerPaddle2.translateZ( -9.5 );
    scene.add(computerPaddle2);

    // ** Create 'nets' behind player paddles **
    // var vertNetGeometry = new THREE.PlaneGeometry(7, 9, 7, 9);
    // var horizNetGeometry = new THREE.PlaneGeometry(16, 7, 16, 7);
    // var netMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true }); 

    // var rightPlayerNet = new THREE.Mesh(vertNetGeometry, netMaterial);
    // rightPlayerNet.translateX(8);
    // rightPlayerNet.translateZ(13.5);
    // rightPlayerNet.rotation.y = 3.14159 / 2;
    // scene.add(rightPlayerNet);
    // netCollidableList.push(rightPlayerNet);
    // var rightPlayerNet = new THREE.Mesh(vertNetGeometry, netMaterial);
    // rightPlayerNet.translateX(8);
    // rightPlayerNet.translateZ(13.5);
    // rightPlayerNet.rotation.y = 3.14159 / 2;
    // scene.add(rightPlayerNet);

    // var leftPlayerNet = new THREE.Mesh(vertNetGeometry, netMaterial);
    // leftPlayerNet.translateX(-8);
    // leftPlayerNet.translateZ(0);
    // leftPlayerNet.rotation.y = 3.14159 / 2;
    // scene.add(leftPlayerNet);
    // yCollidableList.push(leftPlayerNet);
    // var leftPlayerNet = new THREE.Mesh(vertNetGeometry, netMaterial);
    // leftPlayerNet.translateX(-8);
    // leftPlayerNet.translateZ(0);
    // leftPlayerNet.rotation.y = 3.14159 / 2;
    // scene.add(leftPlayerNet);

    // var topPlayerNet = new THREE.Mesh(horizNetGeometry, netMaterial);
    // topPlayerNet.translateY(4.5);
    // topPlayerNet.rotation.x = 3.14159 / 2;
    // scene.add(topPlayerNet);
    // xCollidableList.push(topPlayerNet);
    // var topPlayerNet = new THREE.Mesh(horizNetGeometry, netMaterial);
    // topPlayerNet.translateY(4.5);
    // topPlayerNet.rotation.x = 3.14159 / 2;
    // scene.add(topPlayerNet);

    // var bottomPlayerNet = new THREE.Mesh(horizNetGeometry, netMaterial);
    // bottomPlayerNet.translateY(-4.5);
    // bottomPlayerNet.rotation.x = 3.14159 / 2;
    // scene.add(bottomPlayerNet);
    // xCollidableList.push(bottomPlayerNet);
    // var bottomPlayerNet = new THREE.Mesh(horizNetGeometry, netMaterial);
    // bottomPlayerNet.translateY(4.5);
    // bottomPlayerNet.rotation.x = 3.14159 / 2;
    // scene.add(bottomPlayerNet);

    // var backPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    // backPlane.translateZ( -10 );
    // scene.add(backPlane);
    // zCollidableList.push(backPlane);
    // var backPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    // backPlane.translateZ( -10 );
    // scene.add(backPlane);







    // var netGeometry = new THREE.PlaneGeometry(60, 60, 60, 120);
    // var playerNet = new THREE.Mesh(netGeometry, netMaterial)
    // playerNet.translateZ(24);
    // scene.add(playerNet);
    // netCollidableList.push(playerNet);
    // var playerNet = new THREE.Mesh(netGeometry, netMaterial);
    // playerNet.translateZ(24);
    // scene.add(playerNet);

    // var netGeometry = new THREE.PlaneGeometry(60, 60, 60, 120);
    // var netMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true }); 
    // var computerNet = new THREE.Mesh(netGeometry, netMaterial)
    // computerNet.translateZ(-24);
    // scene.add(computerNet);
    // netCollidableList.push(computerNet);
    // var computerNet = new THREE.Mesh(netGeometry, netMaterial);
    // computerNet.translateZ(-24);
    // scene.add(computerNet);




    // ** Below code is to enable mouse control of the paddle **
    // Code created with the help of Stack Overflow question
    // https://stackoverflow.com/questions/13055214/mouse-canvas-x-y-to-three-js-world-x-y-z
    // Question by Rob Evans:
    // https://stackoverflow.com/users/599020/rob-evans
    // Answer by WestLangley:
    // https://stackoverflow.com/users/1461008/westlangley

    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    var vector = new THREE.Vector3();

    document.addEventListener('mousemove', onDocumentMouseMove, false);

    function onDocumentMouseMove(event) {
      event.preventDefault();

      vector.set(
        (event.clientX / window.innerWidth ) * 2 - 1,
        (event.clientY / window.innerHeight ) * 2 - 1,
        0.5
      )
      vector.unproject(camera);
      var dir = vector.sub(camera.position).normalize();
      var distance = (9.5 - camera.position.z) / dir.z;
      var pos = camera.position.clone().add(dir.multiplyScalar(distance));

      playerPaddle1.position.set(
        pos.x, -pos.y, pos.z);
      playerPaddle2.position.set(
        pos.x, -pos.y, pos.z);
    }

    // ** Below code is to enable WASD keyboard control of the paddle **
    // let xSpeed = 2.25;
    // let ySpeed = 2.25;

    // document.addEventListener("keydown", onDocumentKeyDown, false);
    // function onDocumentKeyDown(event) {
    //   var keyCode = event.which;
    //   if (keyCode == 87) {
    //     playerPaddle1.position.y += ySpeed;
    //   } else if (keyCode == 83) {
    //     playerPaddle1.position.y -= ySpeed;
    //   } else if (keyCode == 65) {
    //     playerPaddle1.position.x -= xSpeed;
    //   } else if (keyCode == 68) {
    //     playerPaddle1.position.x += xSpeed;
    //   } else if (keyCode == 32) {
    //     playerPaddle1.position.set(0, 0, 0);
    //   }
    //   if (keyCode == 87) {
    //     playerPaddle2.position.y += ySpeed;
    //   } else if (keyCode == 83) {
    //     playerPaddle2.position.y -= ySpeed;
    //   } else if (keyCode == 65) {
    //     playerPaddle2.position.x -= xSpeed;
    //   } else if (keyCode == 68) {
    //     playerPaddle2.position.x += xSpeed;
    //   } else if (keyCode == 32) {
    //     playerPaddle2.position.set(0, 0, 0);
    //   }
    // };


    camera.position.z = 18;
    // camera.position.z = -18;
    // camera.rotation.y = 180 * Math.PI / 180


    // camera.rotation.y = 3.14159 / 2;
    // camera.lookAt(scene.sphere);

    var computerPaddleXSpeed = 0.15;
    var computerPaddleYSpeed = 0.15;

    function moveComputerPaddle() {
      if (sphere.position.x > computerPaddle1.position.x) {
        computerPaddle1.translateX(computerPaddleXSpeed);
        computerPaddle2.translateX(computerPaddleXSpeed);
      }
      if (sphere.position.y > computerPaddle1.position.y) {
        computerPaddle1.translateY(computerPaddleYSpeed);
        computerPaddle2.translateY(computerPaddleYSpeed);
      }
      if (sphere.position.x < computerPaddle1.position.x) {
        computerPaddle1.translateX(-computerPaddleXSpeed);
        computerPaddle2.translateX(-computerPaddleXSpeed);
      }
      if (sphere.position.y < computerPaddle1.position.y) {
        computerPaddle1.translateY(-computerPaddleYSpeed);
        computerPaddle2.translateY(-computerPaddleYSpeed);
      }

    }

    var xBallVelocity = 0.2;    
    var yBallVelocity = 0.2; 
    var zBallVelocity = -0.2;  

    function checkPastNet() {
      if (sphere.position.z > 13) {
        incrementPoint("computer");
        resetBall("computer");
      } else if (sphere.position.z < -13) {
        incrementPoint("player");
        resetBall("player");
      };
    }

    let playerPoints = 0;
    let computerPoints = 0;

    function incrementPoint(player) {
      if (player === "computer") {
        computerPoints = computerPoints + 1;
        document.getElementById('comp-score').innerHTML = computerPoints;
      } else if (player === "player") {
        playerPoints = playerPoints + 1;
        document.getElementById('player-score').innerHTML = playerPoints;
      }
      // if (playerPoints >= 10) {
      //   gameOver("player");
      // } else if (computerPoints >= 10) {
      //   gameOver("computer");
      // }
    }

    function resetBall(side) {
      if (side === "computer") {
        sphere.position.set(0, 0, -9.5)
        zBallVelocity = Math.abs(zBallVelocity);
      } else if (side === "player") {
        sphere.position.set(0, 0, 9.5)
        zBallVelocity = -Math.abs(zBallVelocity);
      }
    }

    function animate() {

      requestAnimationFrame(animate);
      render();
      // update();

      moveComputerPaddle();
      checkPastNet()

      var originPoint = sphere.position.clone();
      for (var vertexIndex = 0; vertexIndex < sphere.geometry.vertices.length; vertexIndex++) {
        var localVertex = sphere.geometry.vertices[vertexIndex].clone();
        var globalVertex = localVertex.applyMatrix4(sphere.matrix);
        var directionVector = globalVertex.sub(sphere.position);
        
        var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
        var xCollisionResults = ray.intersectObjects(xCollidableList);
        if (xCollisionResults.length > 0 && xCollisionResults[0].distance < directionVector.length()) {
          yBallVelocity = -yBallVelocity;
        }

        var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
        var yCollisionResults = ray.intersectObjects(yCollidableList);
        if (yCollisionResults.length > 0 && yCollisionResults[0].distance < directionVector.length()) {
          xBallVelocity = -xBallVelocity;
        }
        
        var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
        var zCollisionResults = ray.intersectObjects(zCollidableList);
        if (zCollisionResults.length > 0 && zCollisionResults[0].distance < directionVector.length()) {
          zBallVelocity = -zBallVelocity;
        }

        // var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
        // var netCollisionResults = ray.intersectObjects(netCollidableList);
        // if (netCollisionResults.length > 0 && netCollisionResults[0].distance < directionVector.length()) {
        //   zBallVelocity = -zBallVelocity;
        //   // scene.remove( sphere );
        //   sphere.position.set(0, 0, 0)
        //   // sphere.translateX(0);
        //   // sphere.translateY(0);
        //   // sphere.translateZ(0);
        //   // scene.add( sphere );
        // }
      }

      sphere.translateX(xBallVelocity);
      sphere.translateY(yBallVelocity);
      sphere.translateZ(zBallVelocity);
      }

    function render() {
        renderer.render(scene, camera);
      }

    // function update() {
    
    // }

    animate();

  </script>
</body>

</html>